import React from 'react';
import PropTypes from 'prop-types';
import { createMachine, assign } from 'xstate';
import { useMachine } from '@xstate/react';
import { createMongoId, socket } from 'utils';
import { Room } from 'Model';

export const controlStates = {
  NONE: 'NONE',
  ME: 'ME',
  OTHER: 'OTHER',
  REQUESTED: 'REQUESTED',
  CANCELLED_REQUEST: 'CANCELLED_REQUEST',
  SWITCHING_TABS: 'SWITCHING_TABS',
};

export const controlEvents = {
  CLICK: 'CLICK',
  MSG_RECEIVED: 'MSG_RECEIVED',
  MSG_TOOK_CONTROL: 'MSG_TOOK_CONTROL',
  MSG_RELEASED_CONTROL: 'MSG_RELEASED_CONTROL',
  RESET: 'RESET',
  SWITCH_TAB: 'SWITCH_TAB',
  SWITCH_STRATEGY: 'SWITCH_STRATEGY',
};

export const buttonConfigs = {
  [controlStates.NONE]: {
    text: 'Take Control',
    disabled: false,
  },
  [controlStates.ME]: {
    text: 'Release Control',
    disabled: false,
  },
  [controlStates.OTHER]: {
    text: 'Request Control',
    disabled: false,
  },
  [controlStates.REQUESTED]: {
    text: 'Cancel Request',
    disabled: false,
  },
  [controlStates.CANCELLED_REQUEST]: {
    text: 'Request Control',
    disabled: true,
  },
};
/** ***************************************************************
 * actions taken when certain events occur
 ***************************************************************** */
const iTakeControl = (context, event) => {
  const message = {
    _id: createMongoId(),
    user: { _id: context.userId, username: 'VMTBot' },
    room: context.roomId,
    tab: context.currentTabId,
    text: `${context.username} took control`,
    messageType: 'TOOK_CONTROL',
    autogenerated: true,
    color: event.myColor || '#f26247',
    timestamp: Date.now(),
  };
  socket.emit(
    'TAKE_CONTROL',
    message,
    typeof event.callback === 'function' ? () => event.callback(message) : null
  );
};

const iReleaseControl = (context, event) => {
  const message = {
    _id: createMongoId(),
    user: { _id: context.userId, username: 'VMTBot' },
    room: context.roomId,
    tab: context.currentTabId,
    text: `${context.username} released control`,
    autogenerated: true,
    messageType: 'RELEASED_CONTROL',
    color: event.myColor || '#f26247',
    timestamp: Date.now(),
  };
  socket.emit(
    'RELEASE_CONTROL',
    message,
    typeof event.callback === 'function' ? () => event.callback(message) : null
  );
};

const iTimeOut = (context, event) => {
  const message = {
    _id: createMongoId(),
    user: { _id: context.userId, username: 'VMTBot' },
    room: context.roomId,
    tab: context.currentTabId,
    text: `${context.username} control was released by system`,
    autogenerated: true,
    messageType: 'RELEASED_CONTROL',
    color: event.myColor || '#f26247',
    timestamp: Date.now(),
  };
  socket.emit(
    'RELEASE_CONTROL',
    message,
    typeof event.callback === 'function' ? () => event.callback(message) : null
  );
};

const iRequestControl = (context, event) => {
  const message = {
    _id: createMongoId(),
    text: 'Can I take control?',
    messageType: 'TEXT',
    user: { _id: context.userId, username: context.username },
    room: context.roomId,
    tab: context.currentTabId,
    color: event.myColor || '#f26247',
    timestamp: Date.now(),
  };
  socket.emit(
    'SEND_MESSAGE',
    message,
    typeof event.callback === 'function' ? () => event.callback(message) : null
  );
};

const otherTakesControl = () => {
  // nothing to do
};

const otherReleasesControl = () => {
  // nothing for me to do
};

const iCancelRequest = (context, event) => {
  const message = {
    _id: createMongoId(),
    text: "Nevermind. I don't want control.",
    messageType: 'TEXT',
    user: { _id: context.userId, username: context.username },
    room: context.roomId,
    tab: context.currentTabId,
    color: event.myColor || '#f26247',
    timestamp: Date.now(),
  };
  socket.emit(
    'SEND_MESSAGE',
    message,
    typeof event.callback === 'function' ? () => event.callback(message) : null
  );
};

const controlledByMe = () => {
  assign({
    controlledBy: (c) => c.userId,
    buttonConfig: buttonConfigs[controlStates.ME],
  });
};

const controlledByOther = () => {
  assign({
    controlledBy: (_, event) => event.id,
    buttonConfig: buttonConfigs[controlStates.OTHER],
  });
};

const controlledByNone = () => {
  assign({
    controlledBy: null,
    buttonConfig: buttonConfigs[controlStates.NONE],
  });
};

const controlRequested = () => {
  assign({
    buttonConfig: buttonConfigs[controlStates.REQUESTED],
  });
};

const cancelledRequest = () => {
  assign({
    buttonConfig: buttonConfigs[controlStates.CANCELLED_REQUEST],
  });
};

const switchingTabs = () => {
  assign({
    currentTabId: (_, event) => event.tab,
  });
};

const storeNull = () => {
  assign({
    controllers: (c, event) => ({
      ...c.controllers,
      [event.tab]: null,
    }),
  });
};

const storeController = () => {
  assign({
    controllers: (c, event) => ({
      ...c.controllers,
      [event.tab]: event.id,
    }),
  });
};

const setRestrictFlag = () => {
  assign({
    restrictFlags: (c) => ({
      ...c.restrictFlags,
      [c.currentTabId]: true,
    }),
  });
};

const controlledByMe_ind = () => {
  assign({
    controlledBy: (c) => c.userId,
    controllers: (c) => ({
      ...c.controllers,
      [c.currentTabId]: null,
    }),
    buttonConfig: buttonConfigs[controlStates.ME],
  });
};

const controlledByOther_ind = () => {
  assign({
    controlledBy: (c) => c.controllers[c.currentTabId],
    buttonConfig: buttonConfigs[controlStates.OTHER],
  });
};

const controlledByNone_ind = () => {
  assign({
    controlledBy: null,
    controllers: (c) => ({
      ...c.controllers,
      [c.currentTabId]: null,
    }),
    buttonConfig: buttonConfigs[controlStates.NONE],
  });
};

const cancelledRequest_ind = () => {
  assign({
    buttonConfig: buttonConfigs[controlStates.CANCELLED_REQUEST],
    restrictFlags: (c) => ({
      ...c.restrictFlags,
      [c.currentTabId]: false,
    }),
  });
};

const defaultControlMachineSpec = (initial, context) => {
  return [
    {
      predictableActionArguments: true,
      id: 'control',
      initial,
      context,
      on: {
        [controlEvents.MSG_RELEASED_CONTROL]: {
          target: controlStates.NONE,
          actions: 'otherReleasesControl',
        },
        [controlEvents.MSG_TOOK_CONTROL]: {
          target: controlStates.OTHER,
          actions: 'otherTakesControl',
        },
        [controlEvents.SWITCH_TAB]: { actions: 'switchingTabs' },
      },
      states: {
        [controlStates.NONE]: {
          entry: 'controlledByNone',
          on: {
            [controlEvents.CLICK]: {
              target: controlStates.ME,
              actions: 'iTakeControl',
            },
          },
        },
        [controlStates.ME]: {
          entry: 'controlledByMe',
          on: {
            [controlEvents.CLICK]: {
              target: controlStates.NONE,
              actions: 'iReleaseControl',
            },
            [controlEvents.RESET]: controlStates.ME,
          },
          after: {
            60000: { target: controlStates.NONE, actions: 'iTimeOut' },
          },
        },
        [controlStates.OTHER]: {
          entry: 'controlledByOther',
          on: {
            [controlEvents.CLICK]: {
              target: controlStates.REQUESTED,
              actions: 'iRequestControl',
            },
          },
        },
        [controlStates.REQUESTED]: {
          entry: 'controlRequested',
          on: {
            [controlEvents.CLICK]: {
              target: controlStates.CANCELLED_REQUEST,
              actions: 'iCancelRequest',
            },
          },
          after: {
            60000: controlStates.OTHER,
          },
        },
        [controlStates.CANCELLED_REQUEST]: {
          entry: 'cancelledRequest',
          after: {
            60000: controlStates.OTHER,
          },
        },
      },
    },
    {
      actions: {
        iTakeControl,
        otherTakesControl,
        iReleaseControl,
        iTimeOut,
        iRequestControl,
        otherReleasesControl,
        iCancelRequest,
        controlledByMe,
        controlledByOther,
        controlledByNone,
        controlRequested,
        cancelledRequest,
        switchingTabs,
      },
    },
  ];
};

const independentTabControlMachineSpec = (initial, context) => {
  return [
    {
      predictableActionArguments: true,
      id: 'control',
      initial,
      context,
      on: {
        [controlEvents.MSG_RELEASED_CONTROL]: [
          {
            cond: (c, event) => c.currentTabId === event.tab,
            target: controlStates.NONE,
            actions: ['otherReleasesControl', 'storeNull'],
          },
          {
            cond: (c, event) => c.currentTabId !== event.tab,
            actions: 'storeNull',
          },
        ],
        [controlEvents.MSG_TOOK_CONTROL]: [
          {
            cond: (c, event) => c.currentTabId === event.tab,
            target: controlStates.OTHER,
            actions: ['otherTakesControl', 'storeController'],
          },
          {
            cond: (c, event) => c.currentTabId !== event.tab,
            actions: 'storeController',
          },
        ],
      },
      states: {
        [controlStates.NONE]: {
          entry: 'controlledByNone_ind',
          on: {
            [controlEvents.CLICK]: {
              target: controlStates.ME,
              actions: 'iTakeControl',
            },
            [controlEvents.SWITCH_TAB]: controlStates.SWITCHING_TABS,
          },
        },
        [controlStates.ME]: {
          entry: 'controlledByMe_ind',
          on: {
            [controlEvents.CLICK]: {
              target: controlStates.NONE,
              actions: 'iReleaseControl',
            },
            [controlEvents.RESET]: controlStates.ME,
            [controlEvents.SWITCH_TAB]: {
              target: controlStates.SWITCHING_TABS,
              actions: 'iReleaseControl', // @TODO: potentially different msg if released due to switching
            },
          },
          after: {
            60000: { target: controlStates.NONE, actions: 'iTimeOut' },
          },
        },
        [controlStates.OTHER]: {
          entry: 'controlledByOther_ind',
          on: {
            [controlEvents.CLICK]: {
              target: controlStates.REQUESTED,
              actions: 'iRequestControl',
            },
            [controlEvents.SWITCH_TAB]: controlStates.SWITCHING_TABS,
          },
        },
        [controlStates.REQUESTED]: {
          entry: 'controlRequested',
          on: {
            [controlEvents.CLICK]: {
              target: controlStates.CANCELLED_REQUEST,
              actions: 'iCancelRequest',
            },
            [controlEvents.SWITCH_TAB]: {
              target: controlStates.SWITCHING_TABS,
              actions: ['iCancelRequest', 'setRestrictFlag'], // @TODO: Potentially different message when cancel via switching tabs
            },
          },
          after: {
            60000: controlStates.OTHER,
          },
        },
        [controlStates.CANCELLED_REQUEST]: {
          entry: 'cancelledRequest_ind',
          on: {
            [controlEvents.SWITCH_TAB]: {
              target: controlStates.SWITCHING_TABS,
              actions: 'setRestrictFlag', // @TODO: Potentially different message when cancel via switching tabs
            },
          },
          after: {
            60000: controlStates.OTHER,
          },
        },
        [controlStates.SWITCHING_TABS]: {
          entry: 'switchingTabs',
          always: [
            {
              cond: (c) =>
                !!c.controllers[c.currentTabId] &&
                c.restrictFlags[c.currentTabId],
              target: controlStates.CANCELLED_REQUEST,
            },
            {
              cond: (c) =>
                !!c.controllers[c.currentTabId] &&
                !c.restrictFlags[c.currentTabId],
              target: controlStates.OTHER,
            },
            {
              cond: (c) => !c.controllers[c.currentTabId],
              target: controlStates.NONE,
            },
          ],
        },
      },
    },
    {
      actions: {
        iTakeControl,
        otherTakesControl,
        iReleaseControl,
        iTimeOut,
        iRequestControl,
        otherReleasesControl,
        iCancelRequest,
        storeNull,
        storeController,
        setRestrictFlag,
        switchingTabs,
        controlledByMe_ind,
        controlledByOther_ind,
        controlledByNone_ind,
        controlRequested,
        cancelledRequest_ind,
      },
    },
  ];
};

const combinedMachineSpec = (initial, context) => {
  const { strategy, ...sharedContext } = context;

  const defaultSpec = defaultControlMachineSpec(initial, sharedContext);
  const independentSpec = independentTabControlMachineSpec(
    initial,
    sharedContext
  );

  // Update action references in defaultSpec
  const updatedDefaultSpec = [
    {
      ...defaultSpec[0],
      on: {
        ...defaultSpec[0].on,
        [controlEvents.SWITCH_STRATEGY]: {
          target: controlStates.NONE,
        },
      },
    },
    defaultSpec[1],
  ];

  // Update action references in independentSpec
  const updatedIndependentSpec = [
    {
      ...independentSpec[0],
      on: {
        ...independentSpec[0].on,
        [controlEvents.SWITCH_STRATEGY]: {
          target: controlStates.NONE,
        },
      },
    },
    independentSpec[1],
  ];

  return {
    initial,
    context: sharedContext,
    states: {
      control: {
        initial: strategy === 'default' ? 'default' : 'independent',
        states: {
          default: updatedDefaultSpec[0].states,
          independent: updatedIndependentSpec[0].states,
        },
      },
    },
    on: {
      ...updatedDefaultSpec[0].on,
      ...updatedIndependentSpec[0].on,
    },
    actions: {
      ...updatedDefaultSpec[1].actions,
      ...updatedIndependentSpec[1].actions,
    },
  };
};

/**
 * @returns {Array} [state, send] - 'state' is the current state object. 'send' is a function that receives a control action.
 * Keys parts of state:
 *  - state.meta -- an object that can be handed to controlButton
 *  - state.value -- a string representing the state. Right now, matches with the legacy inControl, so can be used there.
 *
 * Ideally, state would also embed the 'controlledBy' state variable now maintained by Workspace (from the DB). This would allow
 * us to keep the control state in one place (the controlMachine).
 *
 */
export function useControlMachine(context, spec) {
  // Figure out the initial state
  let initial = controlStates.NONE;
  if (!context.controlledBy) initial = controlStates.NONE;
  else if (context.controlledBy === context.userId) initial = controlStates.ME;
  else initial = controlStates.OTHER;

  // use of the Ref prevents the re-creation of the machine, which causes a warning
  const controlMachineRef = React.useRef(null);
  if (!controlMachineRef.current)
    controlMachineRef.current = createMachine(...spec(initial, context));

  const [state, send] = useMachine(controlMachineRef.current);

  return [
    {
      ...state,
      inControl: state.value,
      buttonConfig: state.context.buttonConfig,
      controlledBy: state.context.controlledBy,
      currentTabId: state.context.currentTabId,
    },
    send,
  ];
}

export function withControlMachine(Component) {
  const ControlMachine = (props) => {
    const { populatedRoom, user } = props;
    const [controlStrategy, setControlStrategy] = React.useState(
      Room.getRoomSetting(populatedRoom, Room.TAB_BASED_CONTROL)
    );
    const [state, send] = useControlMachine(
      {
        userId: user._id,
        roomId: populatedRoom._id,
        username: user.username,
        controlledBy: populatedRoom.tabs[0].controlledBy,
        currentTabId: populatedRoom.tabs[0]._id,
        controllers: populatedRoom.tabs.reduce(
          (acc, tab) => ({ ...acc, [tab._id]: tab.controlledBy }),
          {}
        ),
        restrictFlags: {},
        strategy: controlStrategy ? 'independent' : 'default',
      },
      combinedMachineSpec
    );

    React.useEffect(() => {
      if (
        controlStrategy !==
        Room.getRoomSetting(populatedRoom, Room.TAB_BASED_CONTROL)
      ) {
        setControlStrategy(
          Room.getRoomSetting(populatedRoom, Room.TAB_BASED_CONTROL)
        );
        send(controlEvents.SWITCH_STRATEGY);
      }
    }, [populatedRoom]);

    return (
      <Component controlState={state} sendControlEvent={send} {...props} />
    );
  };

  ControlMachine.propTypes = {
    populatedRoom: PropTypes.shape({
      _id: PropTypes.string,
      controlledBy: PropTypes.string,
      tabs: PropTypes.arrayOf(
        PropTypes.shape({
          _id: PropTypes.string,
          controlledBy: PropTypes.string,
        })
      ),
      settings: PropTypes.shape({ independentTabControl: PropTypes.bool }),
    }).isRequired,
    user: PropTypes.shape({ _id: PropTypes.string, username: PropTypes.string })
      .isRequired,
  };

  return ControlMachine;
}
